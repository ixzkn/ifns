using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.Text;
using Microsoft.Win32;
using System.Net;
using System.IO;
using Newtonsoft.Json;
using System.Text.RegularExpressions;

namespace ifns_service_interface
{
	[ServiceBehavior(InstanceContextMode = InstanceContextMode.Single)]
	public class IFDNSServer : IFDNSServerInterface
	{
		private string ValidateHost(string hostname)
		{
			var r = new Regex(@"^[A-Za-z0-9_-]{1,255}$");
			if (!r.IsMatch(hostname))
			{
				throw new FaultException("Invalid hostname");
			}
			if (hostname == "localhost")
			{
				throw new FaultException("Invalid hostname");
			}
			return hostname;
		}

		private string ValidateAddress(string address)
		{
			var r = new Regex(@"^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$");
			if (!r.IsMatch(address))
			{
				throw new FaultException("Invalid address");
			}
			return address;
		}

		private string ValidateAPIKey(string key)
		{
			var r = new Regex(@"^(?:[A-Za-z0-9+_\-/]{4})*(?:[A-Za-z0-9_+\-/]{2}==|[A-Za-z0-9+_\-/]{3}=)?$");
			if (!r.IsMatch(key))
			{
				throw new FaultException("Invalid API key");
			}
			return key;
		}

		private string ValidateUrl(string url)
		{
			Uri uriResult;
			bool result = Uri.TryCreate(url, UriKind.Absolute, out uriResult)
				&& (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps);
			if (!result)
			{
				throw new FaultException("Invalid URL");
			}
			return url;
		}

		public void ReadConfiguration()
		{
			apikeys = new HashSet<string>();
			lastSuccessfulRefresh = DateTime.FromFileTime(0);
			syncHosts = false;
			thisHostSynced = false;
			serverUrl = "https://example.com/index.wsgi";

			// Explicitly dont do anything in these catch blocks, we just use the defaults as specified above
			try
			{
				RegistryKey key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey("SOFTWARE\\ifns_client_service");
				try
				{
					// read initial config
					foreach (var value in key.OpenSubKey("keys").GetValueNames())
					{
						apikeys.Add(ValidateAPIKey(value));
					}
				}
				catch { }
				try
				{
					thisHostSynced = (int)key.GetValue("hostSync") != 0;
					if (thisHostSynced)
					{
						thisHostName = ValidateHost((string)key.GetValue("hostName"));
						thisHostUpdateTime = DateTime.FromFileTime((int)key.GetValue("hostLastUpdate"));
					}
				}
				catch { }
				try
				{
					syncHosts = (int)key.GetValue("syncRemote") == 1;
				}
				catch { }
				try
				{
					serverUrl = ValidateUrl((string)key.GetValue("serverUrl"));
				}
				catch { }
			}
			catch { }
		}

		class HostEntry
		{
			[JsonProperty("name")]
			public string name;
			[JsonProperty("address")]
			public string address;
			[JsonProperty("timestamp")]
			public string timestamp;
		}

		private void WriteHostList(List<HostEntry> list)
		{
			/*		
			Hosts file is modified like follows:
				####~ifns-begin
				# Begin ifns autogenerated
				<blabla>
				# End ifns autogenerated
				####~ifns-end   
			Procedure:
				- if this secion exists, remove it by coping everything below it 
			*/
			const string StartString = "####~ifns-begin";
			const string EndString = "####~ifns-end";

			if (list == null)
			{
				return;
			}

			try
			{
				// NOTE: because of the poor design of System.IO.StreamReader (it precludes getting byte offsets)
				// we have to read the whole file into a buffer here.
				//  if that fails we just fail the whole process (exception), and leave the file alone
				// the linux version of this client does not have this limitation
				string windir = Environment.GetEnvironmentVariable("WINDIR");
				string contents = "";
				string line = "";
				bool cutSection = false;
				string hostsPath = Path.Combine(windir, "System32", "drivers", "etc", "hosts");
				var hosts = new System.IO.StreamReader(hostsPath);
				while ((line = hosts.ReadLine()) != null)
				{
					if (line.Trim() == StartString)
					{
						cutSection = true;
					}
					else if (line.Trim() == EndString)
					{
						contents += hosts.ReadToEnd();
						break;
					}
					else if (!cutSection)
					{
						contents += line + "\r\n";
					}
				}
				hosts.Close();

				var towrite = new System.IO.StreamWriter(hostsPath);
				towrite.Write(contents);
				towrite.Write(StartString + "\r\n# Begin ifns autogenerated\r\n");
				// write hosts
				foreach (var host in list)
				{
					towrite.Write("# " + ValidateHost(host.name.Trim()) + " - updated: " + host.timestamp.Trim() + "\r\n");
					towrite.Write(ValidateAddress(host.address.Trim()) + "    " + ValidateHost(host.name.Trim()) + "\r\n");
				}
				towrite.Write("# End ifns autogenerated\r\n" + EndString + "\r\n");
				towrite.Close();
			}
			catch
			{
				throw new FaultException("Upading hosts file failed");
			}
		}

		private void CheckStillUploaded(List<HostEntry> list)
		{
			if (thisHostSynced)
			{
				bool inHostList = false;
				foreach (var host in list)
				{
					if (host.name == thisHostName)
					{
						inHostList = true;
					}
				}
				if (!inHostList)
				{
					thisHostSynced = false;
					thisHostName = "";
					RegistryKey rkey = Microsoft.Win32.Registry.LocalMachine.CreateSubKey("SOFTWARE\\ifns_client_service");
					rkey.SetValue("hostSync", 0);
					rkey.SetValue("hostName", "");
				}
			}
		}

		private List<HostEntry> GetServerHosts()
		{
			try
			{
				foreach (var key in apikeys)
				{
					HttpWebRequest req = WebRequest.Create(serverUrl) as HttpWebRequest;
					req.Headers.Add("X-Api-Key:" + key);
					using (HttpWebResponse resp = req.GetResponse() as HttpWebResponse)
					{
						StreamReader reader = new StreamReader(resp.GetResponseStream());
						string json = reader.ReadToEnd();
						var hosts = JsonConvert.DeserializeObject<List<HostEntry>>(json);
						// any time we fetch remote hosts, verify that this host still exists
						// if not then say we are not syncing anymore...
						CheckStillUploaded(hosts);
						return hosts;
					}
				}
			}
			catch (WebException ex)
			{
				if (ex.Status == WebExceptionStatus.ProtocolError && ((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.Unauthorized)
				{
					throw new FaultException("Invalid user");
				}
				else
				{
					throw new FaultException("Server error");
				}
			}
			catch
			{
				throw new FaultException("Failed to communicate with server");
			}
			return null;
		}

		// Gets a list of remote hosts
		public IEnumerable<string> GetRemoteHosts()
		{
			List<string> result = new List<string>();
			var hostlist = GetServerHosts();
			if (hostlist != null)
			{
				foreach (var host in hostlist)
				{
					result.Add(host.name);
				}
			}
			return result;
		}

		public void RefreshRemoteHosts()
		{
			if (syncHosts)
			{
				WriteHostList(GetServerHosts());
			}
		}

		public DateTime GetLastUpdate()
		{
			return thisHostUpdateTime;
		}

		public void AddAPIKey(string key)
		{
			apikeys.Add(ValidateAPIKey(key));
			SyncAPIReg();
		}

		public void DelAPIKey(string key)
		{
			apikeys.Remove(key);
			SyncAPIReg();
		}

		void SyncAPIReg()
		{
			RegistryKey rkey = Microsoft.Win32.Registry.LocalMachine.CreateSubKey("SOFTWARE\\ifns_client_service");
			try
			{
				rkey.DeleteSubKeyTree("keys");
			}
			catch { }
			RegistryKey rkey2 = Microsoft.Win32.Registry.LocalMachine.CreateSubKey("SOFTWARE\\ifns_client_service\\keys");
			foreach (var key in apikeys)
			{
				rkey2.SetValue(key, 1);
			}
		}

		public IEnumerable<string> GetAPIKeys()
		{
			return apikeys;
		}

		public void PublishHost(string name)
		{
			ValidateHost(name);
			try
			{
				foreach (var key in apikeys)
				{
					HttpWebRequest req = WebRequest.Create(serverUrl) as HttpWebRequest;
					req.Headers.Add("X-Api-Key:" + key);
					req.Method = "POST";
					req.ContentType = "text/plain";

					byte[] formData = UTF8Encoding.UTF8.GetBytes(name);
					req.ContentLength = formData.Length;
					using (Stream post = req.GetRequestStream())
					{
						post.Write(formData, 0, formData.Length);
					}

					string result = null;
					using (HttpWebResponse resp = req.GetResponse() as HttpWebResponse)
					{
						StreamReader reader = new StreamReader(resp.GetResponseStream());
						result = reader.ReadToEnd();
					}
				}
			}
			catch (WebException ex)
			{
				if (ex.Status == WebExceptionStatus.ProtocolError && ((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.Unauthorized)
				{
					throw new FaultException("Invalid user");
				}
				else
				{
					throw new FaultException("Server error");
				}
			}
			catch
			{
				throw new FaultException("Failed to communicate with server");
			}

			thisHostSynced = true;
			thisHostName = name;
			thisHostUpdateTime = DateTime.Now;

			RegistryKey rkey = Microsoft.Win32.Registry.LocalMachine.CreateSubKey("SOFTWARE\\ifns_client_service");
			rkey.SetValue("hostSync", 1);
			rkey.SetValue("hostName", name);
			rkey.SetValue("hostLastUpdate", thisHostUpdateTime.ToFileTime());
		}

		public void StopHostPublish()
		{
			try
			{
				foreach (var key in apikeys)
				{
					HttpWebRequest req = WebRequest.Create(new Uri(serverUrl + Uri.EscapeDataString(thisHostName))) as HttpWebRequest;
					req.Headers.Add("X-Api-Key:" + key);
					req.Method = "DELETE";
					string result = null;
					using (HttpWebResponse resp = req.GetResponse() as HttpWebResponse)
					{
						StreamReader reader = new StreamReader(resp.GetResponseStream());
						result = reader.ReadToEnd();
					}
				}
			}
			catch (WebException ex)
			{
				if (ex.Status == WebExceptionStatus.ProtocolError && ((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.Unauthorized)
				{
					throw new FaultException("Invalid user");
				}
				else
				{
					throw new FaultException("Server error");
				}
			}
			catch
			{
				throw new FaultException("Failed to communicate with server");
			}

			thisHostSynced = false;
			thisHostName = "";
			thisHostUpdateTime = DateTime.Now;

			RegistryKey rkey = Microsoft.Win32.Registry.LocalMachine.CreateSubKey("SOFTWARE\\ifns_client_service");
			rkey.SetValue("hostSync", 0);
			rkey.SetValue("hostName", "");
		}

		public void SetRemoteSync(bool sync)
		{
			syncHosts = sync;

			RegistryKey rkey = Microsoft.Win32.Registry.LocalMachine.CreateSubKey("SOFTWARE\\ifns_client_service");
			rkey.SetValue("syncRemote", sync ? 1 : 0);
		}

		public bool GetRemoteSync()
		{
			return syncHosts;
		}

		public string GetHost()
		{
			if (thisHostSynced)
			{
				return thisHostName;
			}
			else
			{
				return "";
			}
		}

		string serverUrl;

		HashSet<string> apikeys;
		DateTime lastSuccessfulRefresh;
		bool syncHosts;

		bool thisHostSynced;
		string thisHostName;
		DateTime thisHostUpdateTime;
	}
}
